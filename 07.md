#### 所有权

**所有权**是Rust 用于管理计算机内存的方式。一些语言使用*垃圾回收机制*，或者*亲自分配和释放内存*
通过所有权系统管理内存，编译器在编译时，会根据一系列的规则进行检查。如果违反了这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序

**所有权规则**
1. Rust 中的每一个值都有一个 **所有者**（_owner_）。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者（变量）离开作用域，这个值将被丢弃。

#### 变量作用域

作用域就是一个程序中的范围，例如
```rust
{
	// 变量 s 在这为止都无效
	let s = "hello";  // 此处起，变量 s 有效
	// 有效
} // 作用域结束 变量 s 不再有效
```

#### String 类型
前面已经见过了**字面量**字符串，也就是直接使用双引号声明的字符串，它是被硬编码到程序里的字符串。它很方便，但是因为是硬编码的，所以它是不可变的。但有时需要让他可变，可以使用 `String`类型。然后使用它的 `from`函数，基于字符串字面值来创建`String`

```rust
let s = String::from("Hello World~");
```

`::` 这两个冒号是运算符，允许将特定的`from`函数置于`String`类型的命名空间下，而不需要使用类似`string_from`这样的名字。 [“方法语法”（“Method Syntax”）](https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95)
通过这种方式创建的字符串则可以进行修改

```rust
let mut s = String::from("Hello");
s.push_str("World");
println!("{s}");
```

在作用域中是什么样的呢

```rust
{
	let s = String::from("test"); //从此处起， s 是有效的
	// s 是有效的
}	//此处开始就无效了
```

内存在拥有它的变量离开作用域后就被自动释放了。当变量离开作用域时，Rust会调用一个特殊的函数 `drop`，这个函数里面就可以放置释放内存的代码

###### 变量的移动

```rust
let x = 5;
let y = x;
```
将 `5` 赋值给了 `x` 同时拷贝了`x` 的值给了`y`。因为是已知的简单值，所以被拷贝了放入了栈中
```rust
let s1 = String::from("test");
let s2 = s1;
```
这和上面非常类似，但是并不是，`s1`是由两部分组成的，一个引用地址，和一个实际存储的容量，`s1`实际存储的是引用地址。所以`s2`并没有获取到`s1`的实际存储数据只是拷贝了他的引用地址。因为这是一个复杂的数据，如果数据量过大，全部都拷贝的话会对性能造成非常大的影响。

然后前面提到的，当变量离开作用域后，Rust会自动调用`drop`函数清理变量的堆内存。但是这里两个变量都指向了同一个位置，这就会造成一个问题，他们离开的时候都会释放相同的内存，这个就叫做**二次释放**的错误。也是内存安全性的一个问题。

所以为了确保内存安全，在 `let s2 = s1`之后，Rust  就认为 `s1`不在有效了，这样就可以避免在离开作用域的时候**二次释放**了

```rust
let s1 = String::from("tyest");
let s2 = s1; // 这行之后 s1 就无效了
println!("{s1}")// 这会报错， 因为 s1 无效了
```
这样就解决了我们的问题。另外这还包含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 **自动** 的复制都可以被认为是对运行时性能影响较小的。

###### 克隆
当确实是需要对数据进行深度复刻的时候可以调用 `clone`通用函数
```rust
let s1 = String::from("test");
let s2 = s1.clone();
println!("{s1} {s2}"); // 这样这两个变量就都有效了
```
不过在调用 `clone`时，可能会相当消耗资源
###### 拷贝
```rust
let x = 5;
let y = x;
println!("{x} {y}");
```
这似乎和我们之前学的有矛盾，因为 `x` 依然有效并没有被移动到 `y`，这是因为这个数据是存在栈中的，他的拷贝很快，也就没有必要创建`y`后让`x`失效了。也就是说这里没有深浅拷贝的问题，调不调用`clone`都是一样的

Rust 中有一个叫做 `Copy` trait 的特殊注解，如果一个类型实现了它，那么旧的变量在将其赋值给其他变量后仍然可用，如下是一些 `Copy` 的类型
- 所有整数类型，比如 `u32`。
- 布尔类型，`bool`，它的值是 `true` 和 `false`。
- 所有浮点数类型，比如 `f64`。
- 字符类型，`char`。
- 元组，当且仅当其包含的类型也都实现 `Copy` 的时候。比如，`(i32, i32)` 实现了 `Copy`，但 `(i32, String)` 就没有。

#### 所有权与函数

将值传递给函数与给变量赋值是一样的，向函数传递的值可能会移动或者复制

```rust
fn main() {
	let s = String::from("hello");
	say_hello(s); // 这里之后s 变量就无效了

	let x = 10;
	say_number(x); // 这里之后 x 依然有效因为拷贝了一份简单数据
} // 这里 s 已经被移走了，没有变化，x移除作用域

fn say_hello(msg: String) {
	println!("{}", msg)
} // 这里传入过来的 msg 变量被释放
fn say_number(x: i8) {
	println!("{}", x)
} // 这里拷贝的 x 移出作用域
```

函数参数的传递会转移**所有权**，同样的返回值也会转移**所有权**
```rust
fn main() {
	let s = String::from("hello");

	let s1 = say_hello(s); // 这里开始 s 无效了，同时 s1 有效了

	println!("外层 {}", s1);
}

fn say_hello(msg: String) -> String {
	println!("{}", msg);
	msg // 这里将 msg 返回，因为不是简单数据，所以直接移走了
}
```

> 变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 `drop` 被清理掉，除非数据被移动为另一个变量所有