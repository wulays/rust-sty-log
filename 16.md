#### 模块

模块就是一种组织封装代码的方式，将一些相关的代码，分组在一起，提高代码的可读可维护性，并且支持命名空间

项目开始编译时是从 _crate 根节点_ 开始的，通常，对于一个库 crate 而言是 _src/lib.rs_，对于一个二进制 crate 而言是 _src/main.rs_ 中寻找需要被编译的代码

使用 `mod` 声明一个模块，这里声明了一个`mod1`模块

```rust
mod mod1 {
	//...
}
```

当使用 `mod` 声明一个模块时，编译器就会在以下路径中去查找模块代码
- 内联 _mod mod1_ 然后后方不是一个分号而是大括号
- 文件 _src/mod1.rs_
- 文件 _src/mod1/mod.rs_

当然也可以在内部声明一个子模块

```rust
mod mod1 {
	mod mod1_1 {
		//...
	}
}
```

如果是子模块的话也是类似的
- 如上内联方式
- 文件 _src/mod1/mod1_1.rs_
- 文件 _src/mod1/mod1_1/mod.rs_
类似这样的一个规则去定义模块

一个模块里的代码默认对其父模块私有，当需要让其可以在内部成员公用的时候可以使用 `pub`

```rust
pub mod mod1 {
	pub mod mod1_1 {
		//...
	}
}
```

使用 `use` 关键字给一个成员创建一个快捷方式，减少长路径的重复

```rust
use crate::mod1::mod1_1;

mod1_1::xxx();
```

> 这 crate 就表示根 crate

模块的路径有两种方式，**绝对路径**和**相对路径**，后面跟一个或多个由双冒号（`::`）分割的标识符

- 绝对路径
	- 以 _crate_ 根开头的全路径
- 相对路径
	- 从当前模块开始，以 _self_、_super_ 或当前模块标识符开头

```rust
mod mod1 {
	mod mod1_1 {
		fn test() {}
	}
}

pub fn foo() {
	// 绝对路径
	crate::mod1::mod1_1::test();

	// 相对路径
	mod1::mod1_1::test();

}
```

然而这在编译的时候会出现一个错误 `private module` 这个模块是私有的，拥有了正确的路径，但是Rust 不让使用，再Rust 中 函数 方法 结构体 枚举 模块和常量对父模块都是**私有的**，父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用它们父模块中的项

可以使用 `pub` 关键字创建公共项，使子模块的内部部分暴露给上级模块

```rust
mod mod1 {
	pub mod mod1_1 {
		pub fn test() {}
	}
}
```

模块上的 `pub` 关键字只允许其父模块引用它，所以需要给内部的函数也加上 `pub` ，这样就可以通过 _mod1_ 访问到内部的 _mod1_1_ 和 _test_ 函数了

当然除了这种方式，还有一种相对路径方式，_super_ 开始的相对路径，类似于文件系统中的 _.._ 访问上级目录，也就是父级

```rust
fn test() {

}
mod mod1 {
	fn foo() {
		bar();
		super::test();
	}
	fn bar() {
	
	}
}
```

子模块无法直接访问父级的，所以使用 _super_ ，这样当需要移动代码的时候只需要一起移动他们，就可以了

> 枚举成员默认是公有的，因为如果不是公有的就需要每个都加 _pub_ ，这就显得很恼火了，而且用处不大，而结构体就是默认私有了

无论是绝对路径还是相对路径，都不得不编写路径来调用，调用次数多了就会显得重复且多余，这个时候就可以考虑使用 _use_ 关键字了，创建一个短路径，然后就可以在作用域中使用短路径

```rust
mod mod1 {
	pub mod mod1_1 {
		pub fn test() {}
	}
}

use crate::mod1::mod1_1;

mod1_1::test();

```

当然有时候可能会有多个模块，有重名的情况，或者只是单纯的想给引入进来的改个名字可以使用 _as_ 关键字

```rust
use std::fmt::Result;
use std::io::Result as IoResult;
```

这就就可以导入两个同名的，同时其中一个有了新名称，也就不冲突了

还能使用 _pub use_ 重导出名称，当使用 `use` 关键字导入当前作用域后，这个名称就可以在当前作用域使用了，但是对外依然是私有的，如果要让其他人调用我们的代码也能使用这个名称的话就可以考虑将  `pub` 和 `use` 结合起来，这被称为 _重导出_ 不仅将一个名称导入了当前作用域，还允许别人把它导入他们自己的作用域

```rust
mod mod1 {
	pub mod mod1_1 {
		pub fn test() {}
	}
}

pub use crate::mod1::mod1_1;
```