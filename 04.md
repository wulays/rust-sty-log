#### 数据类型
在Rust中，每一个值都属于一个**数据类型**,用于告诉Rust这个数据是什么类型的，便于明确数据怎么处理。相对于现实中就是将每一个物体分类，杯子，被子，可以用来做什么，例如：杯子可以用来喝水，被子可以用来盖。数值可以用来做计算，布尔值用来做判断。

Rust中的类型大致如下

- 标量类型
	- 整形
	- 浮点型
	- 布尔型
	- 字符型
- 复合类型
	- 元组类型
	- 数组类型

 Rust 是静态类型，在编译的时候就必须知道所有变量的类型，当然通常情况编译器会直接推断出是什么类型

> **标量(scalar) 类型**代表一个单独的值
> **复合类型(Compound Types)** 将多个值组合成一个类型

#### 整型
整数是一个没有小数部分的数字，在Rust中又分为**有符号**和**无符号**代表数值有没有可能是负数，根据整型的大小又分为不同的长度分别为，8，16，32，64，128，和`size`，`size`主要依赖于运行程序的计算机架构，64位架构上它就是 64位的，32位上的就是32位，大致如下

|长度|有符号|无符号|
|---|---|---|
|8-bit|`i8`|`u8`|
|16-bit|`i16`|`u16`|
|32-bit|`i32`|`u32`|
|64-bit|`i64`|`u64`|
|128-bit|`i128`|`u128`|
|arch|`isize`|`usize`|

> `i`表示有符号`u`表示无符号然后跟长度
> 每一个有符号的变体可以储存包含从 -(2n - 1) 到 2n - 1 - 1 在内的数字，这里 _n_ 是变体使用的位数。所以 `i8` 可以储存从 -(27) 到 27 - 1 在内的数字，也就是从 -128 到 127。无符号的变体可以储存从 0 到 2n - 1 的数字，所以 `u8` 可以储存从 0 到 28 - 1 的数字，也就是从 0 到 255。

```rust
let x: i8 = -20;
let y: u8 = 20;
println!("x :{x} y : {}", y)
```
在编写数字面值的时候为了方便读写可以使用 `_` 进行分隔，例如 `1_000` 他的值等同于`1000`
```rust
let x: u16 = 1_000;
println!("x : {x}");
```
###### 整型溢出
例如有一个 `u8`可存放 `0-255`的值，当修改这个值为`256`时，会导致两种情况发生
1. 在 `debug`模式编译时，Rust 会检查这类问题并使程序 `panic`，这个术语表明因错误而退出，详见[“`panic!` 与不可恢复的错误”](https://kaisery.github.io/trpl-zh-cn/ch09-01-unrecoverable-errors-with-panic.html)
2. 使用 `release` 模式时， Rust 不会检测导致 `panic`的整型溢出，相反的发生溢出时，Rust会进行一种二进制补码机制，比最大值大的值会绕回最小值，例如 `256`变成`0`，`257`变为`1`，程序也不会 `panic`，不过变量也不会是你所期望的值
> 使用 `cargo run --release` 使用`release` 模式

```rust
let mut x: u8 = 255;  
println!("x 的值是: {x}");  
x = x + 1;  
println!("x 的值是: {x}");
// 输出
// x 的值是: 255
// x 的值是: 0
```

#### 浮点数
浮点数带小数点的数字，类似于整型，不过整型没有小数，而且所有浮点型都是有符号的。rust中有两种浮点型分别是 `f32`和`f64`
1. f32
2. f64
默认是`f64`，因为在现代CPU 中速度与`f32`几乎一样，同时精度更高。`f32`是单精度`f64`是双精度
```rust
let x = 2.0 // f64
let y: f32 = 3.0 // f32
```

#### 数值运算
在 Rust 中所有数字类型都支持基本的数学运算：加减乘除和取余，不过整型除法会舍去小数点
```rust
let sum = 10 + 1;
let sum2 = 1.0 + 1; // 浮点型不能直接与整型相加，需要手动将其中一个进转换到相同类型
// let sum2 = 1.0 + f64::from(1); 
let sum3 = 1.0 + 1.0;
println!("加法运算的值分别为：{} {} {}", sum, sum2, sum3);
// 加法运算的值分别为：11 2 2
```
> Rust 反对隐式转换，也就不会自动转换，需要手动去转换为相同类型才能继续

#### 布尔类型
布尔类型，主要用于条件表达式例如`if`，有两个只`true`和`false`，Rust中布尔类型使用 `bool`表示
```rust
let a = true;
let b: bool = false;
```
#### 字符类型
`char`类型语言中原生的字母类型，使用单引号声明 `char`字面量，如果是双引号声明的就是字符串了，Rust中`char`大小为四个字节，这代表字符可以使用中文等比 ASCII 表示更多内容
```rust
let a = 'a';
let b = 'B';
let c = '好';
println!("{} {} {}", a, b, c);
// a B 好
```

#### 复合类型
将多个值组成为一个类型，Rust中有两个原生的复合类型
1. 元组（tuple）
2. 数组（array）

#### 元组
使用圆括号来创建一个元组，用逗号分隔其中的值列表，元组中每一个位置都有一个类型，这些类型值也能是不同的
```rust
let tup: (i32, u8, f32) = (1000, 255, 3.2);
```

> 元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小

因为元组是一个单独的整体，为了从元组中获取单个值可以使用模式匹配来解构元组值，如下
```rust
let tup = (100, 500, 3.2);
let (a, b, c) = tup;
println!("{} {} {}", a, b, c);
```

这种方式将一个元组拆分为了多个变量，这叫做 `解构`,当然也可以直接使用 `.` 跟上索引值嘞直接访问他们，第一个元素索引是 `0`依次累计
```rust
let tup = (1000, 3.2, 243, true);
println!("{} {} {}", tup.1, tup.3, tup.0);
```

> 如果元组中没有任何值，它就叫做`单元`元组，这种值和类型都写为 `()`，表示值或者空返回类型
，如果表达式不返回其他值，则隐式返回`单元`

#### 数组
和元组很像，也包含多个值，不同的是数组中每个元素的类型都一样，在Rust中数组长度也是固定的，数组值写在方括号内，用逗号分隔
```rust
let arr = [1, 2, 3, 4, 5];
```
> 当确定元素个数不会改变时，则应该使用数组，例如一年的十二个月，这是确定了的，不然则应该使用 `vector`类型 `vector` 是标准库提供的一个允许增长和缩小长度的类似数组的集合类型

可以使用方括号，元素类型，分号，数组元素数量来声明一个数组类型
```rust
let arr: [bool: 3] = [false, false, true];
```
这里就表示是 `bool`类型，3个`bool`组成的数组
也可以使用方括号初始值分号在加元素个数来创建一个每个元素都相同的数组
```rust
let arr = [10: 5];
// 效果等同于
let arr1 = [10, 10, 10, 10, 10]
```
这里表示 `arr`数组将包含 `5`个元素，同时他们的初始值都是`10`，这种写法更简洁

和元组一样可以使用索引来直接访问
```rust
let arr = [1, 2, 3, 4, 5];
let a = a[0]
```
当然也可以解构
```rust
let arr = [1, 2, 3, 4, 5];  
let [a, b, c, d, e] = arr;  
println!("{} {} {} {} {}", a, b, c, d, e);
```