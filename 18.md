#### 集合

集合，类似于数组，存储一系列的值，不过集合的数据存储在堆上，意味着不用像数组数据的数量一样编译时期就已知。还可以随着程序的运行增长或缩小

> **字符串**（_string_）是字符的集合。我们之前见过 `String` 类型

__vector__ 也就是集合，只能存储相同类型的值 `Vec<T>`后面的 `T` 表示泛型，因为 Rust 并不知道我们要存储声明类型，所以得显示的传递过去

```rust
let v: Vec<i32> = Vec::new();
```

新建了一个空的 __vector__ 用来存储 `i32` 类型的值

为了方便使用 Rust 还提供了一个 _vec!_ 宏，这个宏会根据提供的值创建一个新的 __vector__，这样就不用去手动标注类型了

```rust
let v = vec![1, 2, 3];
```

既然可以随着程序的运行而变化，当然就可以添加元素等，使用 _push_ 方法，添加元素，当然了要 _push_ 还是需要允许变量可变的嘛

```rust
let mut v = vec![1, 2, 3];
v.push(5);
v.push(6);
v.push(7);
```

如果要读取里面的值的话可以使用索引语法，就和数组一样，或者使用 _get_ 方法

```rust
v[0];
v.get(0);
```

使用 _get_ 会得到一个可以用于 `match` 的 `Option<&T>`，如果是 `[]` 就会直接得到值，但是当超出元素范围时，如果还使用 `[]` 就会报错了，导致程序崩溃

```rust
let v = vec![1, 2, 3];
// v[100]; 会报错
v.get(100);
```

当可能会超出范围的时候使用 _get_ 就友好很多了，因为它没有导致程序崩溃

当集合有一个不可变引用时，如果使用 _push_ 也会出现一个编译错误
```rust
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];
v.push(6);
println!("The first element is: {first}");
```

这样也是不行的，因为在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。

可以使用循环依次访问集合中的每一个元素

```rust
let v = vec![100, 32, 57];
for i in &v {
	println!("{i}");
}
```

当然也可以可变的修改每一个元素

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
	*i += 50;
}
```

这里涉及到了解引用 _*_  获取 `i` 中的值，不过多纠结 这个后续在说

当然如果想用集合存储 “不同类型” 的值，还是有一种骚操作的，使用枚举来存储多种类型的值，因为集合只能存储相同类型的值，而枚举的成员都定义为相同的枚举类型

```rust
enum Test {
	Int(i32),
	Float(f64),
	Text(String)
}

let row = vec![
	Test::Int(10),
	Test::Text(String::from("foo")),
	Test::Float(10.08)
];
```

除了这些方法还有一个 _pop_ 方法，它会移除并返回 vector 的最后一个元素

```rust
let mut v = vec![1, 2, 3, 4];  
  
if let Some(i) = v.pop() {  
    println!("{}", i);  
}
```

这个方法返回的也会是一个 `Option<T>` 枚举，预防空的情况

类似于任何其他的 `struct`，vector 在其离开作用域时会被释放

```rust
{
	let v = vec![1, 2, 3, 4];
} // 这里之后 v 就失效了
```